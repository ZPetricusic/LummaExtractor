#!/usr/bin/env python3

# Reference sample:
# MD5 - 7b9d92a070564e3f3c3bdd56aad15fb9
# SHA1 - 65c99d8bb9fd338d26711e1a93c8aa017bf7258c
# SHA256 - 50e5e5c6d0f84c47ea75b91999f0d4f55d37ba44252f69d8b9d3c6561ee77d7b
# https://www.virustotal.com/gui/file/50e5e5c6d0f84c47ea75b91999f0d4f55d37ba44252f69d8b9d3c6561ee77d7b/community
# https://app.any.run/tasks/5d02d2fd-07b7-47f6-9ad1-58e237a14167

import os
import re
import sys
import json
import struct
import binascii
from Crypto.Cipher import ChaCha20

# Constants
KEY_STREAM_CHUNK_SIZE = 0x40  # 64
ENCRYPTED_BLOCK_SIZE = 0x80
DOMAIN_REGEX = re.compile(
    r"^(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?\.)+[a-z0-9][a-z0-9-]{0,61}[a-z0-9]$", re.IGNORECASE)

# Patterns
key_pattern = b"\x32\x1D\x30\xF9\x48\x77\x82\x5A\x3C\xBF\x73\x7F\xDD\x4F\x15\x75"
encrypted_blocks_followup_pattern = b"\x30\x30\x30\x31\x30\x32\x30\x33\x30\x34\x30\x35\x30\x36\x30\x37\x30\x38\x30\x39\x31\x30\x31\x31\x31\x32\x31\x33\x31\x34\x31\x35\x31\x36\x31\x37\x31\x38\x31\x39\x32\x30\x32\x31\x32\x32\x32\x33\x32\x34\x32\x35\x32\x36\x32\x37\x32\x38\x32\x39\x33\x30\x33\x31\x33\x32\x33\x33\x33\x34\x33\x35\x33\x36\x33\x37\x33\x38\x33\x39\x34\x30\x34\x31\x34\x32\x34\x33\x34\x34\x34\x35\x34\x36\x34\x37\x34\x38\x34\x39\x35\x30\x35\x31\x35\x32\x35\x33\x35\x34\x35\x35\x35\x36\x35\x37\x35\x38\x35\x39\x36\x30\x36\x31\x36\x32\x36\x33\x36\x34\x36\x35\x36\x36\x36\x37\x36\x38\x36\x39\x37\x30\x37\x31\x37\x32\x37\x33\x37\x34\x37\x35\x37\x36\x37\x37\x37\x38\x37\x39\x38\x30\x38\x31\x38\x32\x38\x33\x38\x34\x38\x35\x38\x36\x38\x37\x38\x38\x38\x39\x39\x30\x39\x31\x39\x32\x39\x33\x39\x34\x39\x35\x39\x36\x39\x37\x39\x38\x39\x39\x00\x30\x30\x30\x31\x30\x32\x30"
build_id_pattern = b"\xfe\xdc\xba\x98\x76\x54\x32\x10\xf0\xe1\xd2\xc3"

steam_username_wrapper = '<span class="actual_persona_name">'

# generated by coderex (https://github.com/intel471/coderex)
# values being moved to *ebx replaced with wildcards
# since these are not static
steam_profile_regex = re.compile(
    (
        # mov dword ptr [ebx],59E45FF6h ; '.{6}'
        rb'\xc7[\x00-\x03\x06\x07]([\x00-\xff]{4})'
        # mov dword ptr [ebx+4],25945BE6h ; '.{7}'
        rb'\xc7[\x40-\x43\x46\x47]\x04([\x00-\xff]{4})'
        # mov dword ptr [ebx+8],21DA2795h ; '.{7}'
        rb'\xc7[\x40-\x43\x46\x47]\x08([\x00-\xff]{4})'
        # mov dword ptr [ebx+0Ch],2DDB23D5h ; '.{7}'
        rb'\xc7[\x40-\x43\x46\x47]\x0c([\x00-\xff]{4})'
        # mov dword ptr [ebx+10h],29942F9Dh ; '.{7}'
        rb'\xc7[\x40-\x43\x46\x47]\x10([\x00-\xff]{4})'
        # mov dword ptr [ebx+14h],35952B87h ; '.{7}'
        rb'\xc7[\x40-\x43\x46\x47]\x14([\x00-\xff]{4})'
        # mov dword ptr [ebx+18h],31933783h ; '.{7}'
        rb'\xc7[\x40-\x43\x46\x47]\x18([\x00-\xff]{4})'
        # mov dword ptr [ebx+1Ch],3D893385h ; '.{7}'
        rb'\xc7[\x40-\x43\x46\x47]\x1c([\x00-\xff]{4})'
        # mov dword ptr [ebx+20h],39853F8Bh ; '.{7}'
        rb'\xc7[\x40-\x43\x46\x47]\x20([\x00-\xff]{4})'
        # mov dword ptr [ebx+24h],5AD3B8Ch ; '.{7}'
        rb'\xc7[\x40-\x43\x46\x47]\x24([\x00-\xff]{4})'
        # mov dword ptr [ebx+28h],1B907BAh ; '.{7}'
        rb'\xc7[\x40-\x43\x46\x47]\x28([\x00-\xff]{4})'
        # mov dword ptr [ebx+2Ch],0DAF03F4h ; '.{7}'
        rb'\xc7[\x40-\x43\x46\x47]\x2c([\x00-\xff]{4})'
        # mov dword ptr [ebx+30h],9BD0FB9h ; '.{7}'
        rb'\xc7[\x40-\x43\x46\x47]\x30([\x00-\xff]{4})'
        # mov dword ptr [ebx+34h],15A40BFDh ; '.{7}'
        rb'\xc7[\x40-\x43\x46\x47]\x34([\x00-\xff]{4})'
        # mov dword ptr [ebx+38h],11A717A4h ; '.{7}'
        rb'\xc7[\x40-\x43\x46\x47]\x38([\x00-\xff]{4})'
        # mov dword ptr [ebx+3Ch],1DB513BCh ; '.{7}'
        rb'\xc7[\x40-\x43\x46\x47]\x3c([\x00-\xff]{4})'
        # mov dword ptr [ebx+40h],19B51FAAh ; '.{7}'
        rb'\xc7[\x40-\x43\x46\x47]\x40([\x00-\xff]{4})'
        # mov dword ptr [ebx+44h],0E5131BA9h ; '.{7}'
        rb'\xc7[\x40-\x43\x46\x47]\x44([\x00-\xff]{4})'
        # mov dword ptr [ebx+48h],0E11EE719h ; '.{7}'
        rb'\xc7[\x40-\x43\x46\x47]\x48([\x00-\xff]{4})'
        # mov dword ptr [ebx+4Ch],0ED12E31Fh ; '.{7}'
        rb'\xc7[\x40-\x43\x46\x47]\x4c([\x00-\xff]{4})'
        # mov dword ptr [ebx+50h],0E919EF1Fh ; '.{7}'
        rb'\xc7[\x40-\x43\x46\x47]\x50([\x00-\xff]{4})'
        # mov dword ptr [ebx+54h],0F50DEB13h ; '.{7}'
        rb'\xc7[\x40-\x43\x46\x47]\x54([\x00-\xff]{4})'
        # mov dword ptr [ebx+58h],0F102F70Eh ; '.{7}'
        rb'\xc7[\x40-\x43\x46\x47]\x58([\x00-\xff]{4})'
        # mov dword ptr [ebx+5Ch],0FD0FF300h ; '.{7}'
        rb'\xc7[\x40-\x43\x46\x47]\x5c([\x00-\xff]{4})'
        # mov dword ptr [ebx+60h],0F905FF01h ; '.{7}'
        rb'\xc7[\x40-\x43\x46\x47]\x60([\x00-\xff]{4})'
        # mov dword ptr [ebx+64h],0C536FB0Bh ; '.{7}'
        rb'\xc7[\x40-\x43\x46\x47]\x64([\x00-\xff]{4})'
        # mov dword ptr [ebx+68h],0C1C0C73Eh ; '.{7}'
        rb'\xc7[\x40-\x43\x46\x47]\x68([\x00-\xff]{4})'
        # mov eax,23A14BAh ; '.{5}' - this is the key
        rb'[\xb8-\xbb\xbe\xbf]([\x00-\xff]{4})'
    ), re.DOTALL
)


def perror(msg: str, e: Exception = None, _exit: bool = True) -> None:
    print(f"[!] {msg}", file=sys.stderr)
    if e is not None:
        print(
            f"Error: {type(e).__name__} at line {e.__traceback__.tb_lineno} of '{__file__}': {e}",
            file=sys.stderr
        )
    if _exit:
        sys.exit(1)


def file_exists(filepath) -> bool:
    return os.path.exists(filepath) and os.path.isfile(filepath)


def is_file_pe(header: bytes) -> bool:
    '''
    Checks the file header to match the PE header
    '''
    return struct.unpack("<H", header)[0] == 0x5A4D


def find_build_id(data: bytes) -> str:
    '''
    Extracts the build ID from the binary
    as a plaintext string.

    Note: some implementations divide the string
    into Build and User IDs, based on the divider ('--'),
    however, this does not appear to be standard practice,
    so this script keeps it together.
    '''
    # The build ID string comes after the
    # build_id_pattern in the binary
    # and is a null-terminated string
    try:
        build_id_start_index = data.index(
            build_id_pattern) + len(build_id_pattern)
        null_terminator = data.index(b"\x00", build_id_start_index)
    except ValueError as e:
        perror("[!] Error while searching locating build ID!", e)

    return data[build_id_start_index: null_terminator].decode('utf-8')


def find_key_and_nonce(data: bytes) -> tuple[bytes, bytes]:
    '''
    Looks for the hardcoded ChaCha20 key and nonce
    based on positions of certain byte patterns in the binary.
    '''
    # Similar to the build ID, the key and nonce
    # come after a certain pattern in the binary.
    # The first 32 bytes after the pattern are the key bytes.
    # The next 8 are the last 8 bytes of the padding.
    key_start_index = 0
    try:
        key_start_index = data.index(key_pattern) + len(key_pattern)
    except ValueError as e:
        perror("[!] Error while searching for key/nonce!", e)

    nonce_offset = key_start_index + ChaCha20.key_size
    key = data[key_start_index: nonce_offset]

    # nonce is 12 bytes long
    # prefixed with 4 0x00 bytes
    # e.g. 00 00 00 00 6D F0 CF 28 61 9F D6 F3
    nonce = b"\x00" * 4
    nonce += data[nonce_offset: nonce_offset + 0x8]

    return key, nonce


def is_valid_domain(potential_c2: bytes) -> bool:
    '''
    Validates that the decrypted content:
        - contains a null-terminator
        - can be decoded as utf-8
        - all the characters are printable
        - it matches a domain regex
    '''
    try:
        # if it doesnt end in a null-term,
        # or can't be encoded properly
        # it's not a valid string
        potential_c2 = potential_c2[: potential_c2.index(
            b"\x00")].decode('utf-8')
    except Exception:
        return False

    # is everything printable?
    if not potential_c2.isprintable():
        return False

    # if it looks like one, sounds like one, and walks like one...
    return re.match(DOMAIN_REGEX, potential_c2) is not None


def decrypt_domains(data: bytes, key: bytes, nonce: bytes) -> list:
    '''
    Decrypts an encrypted domain chunk using ChaCha20.
    The counter variable is dynamically discovered by
    'counting' the number of encrypted blocks. Unlike some other
    implementations, the number of domains is not hardcoded.
    Instead, once a block is decrypted and it doesn't look like a domain
    any more, the function declares that no more domains are present.

    Note: this implementation of ChaCha20 uses a different counter
    than what may be found in tools like CyberChef - the counter
    seems to always be half the size it is in CyberChef,
    e.g. python_counter * 2 == cyberchef_counter
    '''
    domains = []
    data_end_index = 0
    try:
        data_end_index = data.index(encrypted_blocks_followup_pattern)
    except ValueError as e:
        perror("[!] Error while trying to locate encrypted domains block", e)

    cipher = ChaCha20.new(key=key, nonce=nonce)

    # First, we must find what the counter is
    # as it gives us the number of domains.
    # Typically there will be less than 10 domains
    # but we set an arbitrary upper bound (256)
    # to avoid infinite loops.
    counter = 0
    last_block_start = data_end_index - ENCRYPTED_BLOCK_SIZE
    for ctr in range(256):
        # set the counter by seeking the keystream
        cipher.seek(ctr * ENCRYPTED_BLOCK_SIZE)
        potential_c2 = cipher.decrypt(
            data[last_block_start: last_block_start + ENCRYPTED_BLOCK_SIZE])
        # if we've found the max counter value
        # (value of the counter for the last entry)
        # we will successfully decrypt the C2
        if is_valid_domain(potential_c2):
            counter = ctr
            c2 = potential_c2[: potential_c2.index(b"\x00")].decode('utf-8')
            domains.append(c2)
            break

    # start with the second to last block
    # and make our way backwards
    for ctr in range(counter - 1, -1, -1):
        last_block_start = last_block_start - ENCRYPTED_BLOCK_SIZE
        cipher.seek(ctr * ENCRYPTED_BLOCK_SIZE)
        potential_c2 = cipher.decrypt(
            data[last_block_start: last_block_start + ENCRYPTED_BLOCK_SIZE])
        if not is_valid_domain(potential_c2):
            # get rid of the b'' prefix
            print(
                "[*] Entry does not appear to be a valid domain - all blocks likely exhausted. Breaking.", file=sys.stderr)
            print(
                f"Entry (first 8 bytes): {binascii.hexlify(potential_c2[:8]).decode('utf-8')}", file=sys.stderr)
            break
        c2 = potential_c2[: potential_c2.index(b"\x00")].decode('utf-8')
        domains.insert(0, c2)

    return domains


def decrypt_steam_profile_link(link: bytes, key: int) -> str:
    '''
    Based on the data gathered from the regex capture groups,
    the function decrypts the link using several easy-to-follow steps.
    These were purposely written verbosely to better match the disassembly.
    '''
    decrypted_link = b""
    # movzx ecx,byte ptr ds:[ebx+eax-23A14BA]
    for char in link:
        # xor ecx,eax
        char = (char ^ key) & 0xFF
        # mov edx,ecx
        edx = char
        # not edx
        # we only need the lower (DL) bytes
        edx = 0xFF - int(edx)
        # and edx,E4
        edx = edx & 0xE4
        # and ecx,1B
        char = char & 0x1B
        # sub ecx,edx
        char = (char - edx) & 0xFF
        # mov byte ptr ds:[ebx+eax-23A14BA],cl
        decrypted_link += char.to_bytes(length=1, byteorder='little')
        # inc eax
        key += 1

    try:
        # remove the null bytes as a sanity check
        decrypted_link = decrypted_link.replace(b"\x00", b"")
        decrypted_link = decrypted_link.decode('utf-8')
        if decrypted_link.isprintable():
            return decrypted_link
        else:
            return None
    except Exception:
        return None


def rot15(text: str) -> str:
    from string import ascii_lowercase
    alphabet = ascii_lowercase
    shifted_alphabet = alphabet[15:] + alphabet[:15]
    translation_table = str.maketrans(
        alphabet + alphabet.upper(), shifted_alphabet + shifted_alphabet.upper())
    return text.translate(translation_table)


def get_c2_from_steam_username(link: str) -> str:
    '''
    Fetches the HTML of the Steam user profile,
    extracts the username, and runs it through
    ROT15 to decrypt the final domain.
    '''
    import requests
    try:
        r = requests.get(link)
        username_start_index = r.text.index(
            steam_username_wrapper) + len(steam_username_wrapper)
        username_end_index = r.text.index('</span>', username_start_index)
        username = r.text[username_start_index:username_end_index]
        return rot15(username)
    except Exception as e:
        perror(
            f"Failed to get steam username from link: '{link}'", e, _exit=False)
        return None


def get_domain_from_steam_profile(data: bytes) -> str:
    '''
    Fetches an additional C2 domain from a Steam profile
    username. The username is ran through ROT15 to decrypt the domain.

    While other samples were analyzed which contacted steam,
    the algorithm appears slightly different and did not work
    such a sample can be found here:
     - https://www.unpac.me/results/be25ea99-1eef-4843-8f7f-9464df59788e (unpacked child)
     - https://app.any.run/tasks/52c023de-dbf2-4698-8abb-886b91450692
    Nevertheless, normal c2 domains were extracted,
    just the steam one wasn't
    '''
    matched_chunk = re.findall(steam_profile_regex, data)
    if len(matched_chunk) == 0:
        print('[!] Steam chunk not found! Skipping')
        return None

    print("[+] Steam chunk found! Attempting to decrypt")

    # we got a list which looks something like:
    # [(b'...', b'...', b'...',...)]
    # hence the [0]
    # the last chunk is the decryption key
    encrypted_link = b''.join(matched_chunk[0][:-1])
    # each byte is XOR'd with the entire key
    # as a 32-bit integer
    key = struct.unpack("<I", matched_chunk[0][-1])[0]

    print(f"Encrypted link: {binascii.hexlify(encrypted_link)}")
    print(f"Key: {key}")

    decrypted_link = decrypt_steam_profile_link(encrypted_link, key)
    if decrypted_link is None:
        print("[!] Failed to decrypt steam link, C2 data may be incomplete")
        return None

    print(f"[+] Link successfully decrypted! URL: {decrypted_link}")

    print("[*] Getting C2 domain from URL")
    c2 = get_c2_from_steam_username(decrypted_link)
    if c2 is None:
        print(f"[!] Failed to get C2 domain from Steam URL, C2 data may be incomplete")
        return None

    print(f"[+] C2 domain successfully retrieved! Domain: {c2}")
    return c2


def main():
    filepath = input("Enter the path to the Lumma file: ")

    if not file_exists(filepath):
        perror(f"File {filepath} not found! Exiting")

    with open(filepath, "rb") as infile:
        data = infile.read()

        mz_header = data[0:2]
        if not is_file_pe(mz_header):
            perror(f"File {filepath} is not a valid PE file! Exiting")

        print("[*] Decrypting C2 domains embedded in the binary")
        build_id = find_build_id(data)
        key, nonce = find_key_and_nonce(data)
        domains = decrypt_domains(data, key, nonce)

        # remove duplicates
        seen = set()
        seen_add = seen.add
        domains = [x for x in domains if not (x in seen or seen_add(x))]

        print("[*] Attempting to find Steam profile chunk for additional domains")
        steam_c2 = get_domain_from_steam_profile(data)

        config = {'LummaC2': {
            'build_id': build_id,
            'c2': domains,
            'steam_c2': steam_c2
        }}

        print("\n[+] Configuration obtained!")
        print(json.dumps(config, indent=2))


if __name__ == "__main__":
    main()
